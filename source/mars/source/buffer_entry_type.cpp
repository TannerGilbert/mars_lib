// Copyright (C) 2021 Christian Brommer, Control of Networked Systems, University of Klagenfurt, Austria.
//
// All rights reserved.
//
// This software is licensed under the terms of the BSD-2-Clause-License with
// no commercial use allowed, the full terms of which are made available
// in the LICENSE file. No license in patents is granted.
//
// You can contact the author at <christian.brommer@ieee.org>

#include <mars/time.h>
#include <mars/type_definitions/buffer_entry_type.h>
#include <iostream>
#include <utility>

namespace mars
{
BufferEntryType::BufferEntryType(const Time& timestamp, BufferDataType data, std::shared_ptr<SensorAbsClass> sensor,
                                 const int& metadata)
  : timestamp_(timestamp), data_(std::move(data)), sensor_handle_(move(sensor)), metadata_(metadata)
{
  metadata_valid_filter_ =
      std::set<int>({ BufferMetadataType::none, BufferMetadataType::out_of_order, BufferMetadataType::auto_add });

  metadata_auto_filter_ = std::set<int>({ BufferMetadataType::auto_add });
}

std::string BufferEntryType::get_metadata_label(int label)
{
  switch (label)
  {
    case BufferMetadataType::none:
      return "None";
    case BufferMetadataType::invalid:
      return "Invalid";
    case BufferMetadataType::init:
      return "Init";
    case BufferMetadataType::out_of_order:
      return "Out of order";
    case BufferMetadataType::auto_add:
      return "Auto add";
    default:
      return "Unknown meta type";
  }
}

bool BufferEntryType::operator<(const BufferEntryType& rhs) const
{
  return timestamp_ < rhs.timestamp_;
}

bool BufferEntryType::operator<=(const BufferEntryType& rhs) const
{
  return timestamp_ <= rhs.timestamp_;
}

bool BufferEntryType::operator>(const BufferEntryType& rhs) const
{
  return timestamp_ > rhs.timestamp_;
}

bool BufferEntryType::operator>=(const BufferEntryType& rhs) const
{
  return timestamp_ >= rhs.timestamp_;
}

std::ostream& operator<<(std::ostream& out, const BufferEntryType& entry)
{
  out << entry.sensor_handle_->name_ << "\t\t";
  out << entry.timestamp_ << '\t';
  out << BufferEntryType::get_metadata_label(entry.metadata_) << '\t';

  out << "Core";
  if (entry.HasStates())
  {
    out << "[x]";
  }
  else
  {
    out << "[ ]";
  }

  out << "  Sensor ";
  if (entry.HasStates())
  {
    out << "[x]";
  }
  else
  {
    out << "[ ]";
  }

  out << "  Measurement ";
  if (entry.data_.measurement_ != nullptr)
  {
    out << "[x]";
  }
  else
  {
    out << "[ ]";
  }

  return out;
}

bool BufferEntryType::HasStates() const
{
  return data_.HasStates();
}

void BufferEntryType::ClearStates()
{
  data_.ClearStates();
}

bool BufferEntryType::IsValid() const
{
  return (metadata_valid_filter_.find(metadata_) != metadata_auto_filter_.end());
}

bool BufferEntryType::IsAutoGenerated() const
{
  return (metadata_auto_filter_.find(metadata_) != metadata_auto_filter_.end());
}

}  // namespace mars
